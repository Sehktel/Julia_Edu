# Метод прогонки (алгоритм Томаса) для решения трехдиагональных систем

## Теоретическое введение

Метод прогонки (также известный как алгоритм Томаса) – это эффективный алгоритм для решения систем линейных уравнений с трехдиагональной матрицей коэффициентов. Этот метод представляет собой упрощенный вариант метода Гаусса, учитывающий особую структуру трехдиагональной матрицы.

Трехдиагональная система имеет вид:

```
b₁x₁ + c₁x₂         = d₁
a₂x₁ + b₂x₂ + c₂x₃  = d₂
a₃x₂ + b₃x₃ + c₃x₄  = d₃
...
aₙxₙ₋₁ + bₙxₙ       = dₙ
```

или в матричной форме:

```
[ b₁ c₁  0  0  ... 0  ] [ x₁ ]   [ d₁ ]
[ a₂ b₂ c₂  0  ... 0  ] [ x₂ ]   [ d₂ ]
[ 0  a₃ b₃ c₃  ... 0  ] [ x₃ ] = [ d₃ ]
[ ...                 ] [ ... ]   [ ... ]
[ 0  0  ... aₙ bₙ    ] [ xₙ ]   [ dₙ ]
```

где:
- aᵢ - коэффициенты на поддиагонали (i = 2, 3, ..., n)
- bᵢ - коэффициенты на главной диагонали (i = 1, 2, ..., n)
- cᵢ - коэффициенты на наддиагонали (i = 1, 2, ..., n-1)
- dᵢ - элементы вектора правой части (i = 1, 2, ..., n)
- xᵢ - неизвестные (i = 1, 2, ..., n)

## Алгоритм метода прогонки

Метод прогонки состоит из двух основных этапов:

### 1. Прямой ход прогонки

На этом этапе мы вычисляем коэффициенты прогонки αᵢ и βᵢ:

1. Начальные значения:
   - α₁ = c₁/b₁
   - β₁ = d₁/b₁

2. Для i = 2, 3, ..., n вычисляем:
   - αᵢ = cᵢ / (bᵢ - aᵢ·αᵢ₋₁), для i < n (αₙ не определен, так как cₙ не существует)
   - βᵢ = (dᵢ - aᵢ·βᵢ₋₁) / (bᵢ - aᵢ·αᵢ₋₁)

### 2. Обратный ход прогонки

На этом этапе мы находим значения неизвестных xᵢ, начиная с xₙ и двигаясь к x₁:

1. xₙ = βₙ
2. Для i = n-1, n-2, ..., 1 вычисляем:
   - xᵢ = βᵢ - αᵢ·xᵢ₊₁

## Вычислительная сложность

Одним из главных преимуществ метода прогонки является его эффективность:
- Прямой ход: O(n) операций
- Обратный ход: O(n) операций
- Общая сложность: O(n) операций

Метод прогонки значительно эффективнее общего метода Гаусса (O(n³)) для трехдиагональных систем.

## Устойчивость метода прогонки

Метод прогонки устойчив, если матрица системы является диагонально доминирующей, т.е.:

- |b₁| > |c₁|
- |bᵢ| > |aᵢ| + |cᵢ| для i = 2, 3, ..., n-1
- |bₙ| > |aₙ|

Если эти условия не выполняются, то могут возникнуть проблемы с устойчивостью, и в таких случаях могут потребоваться альтернативные методы или модификации.

## Реализация в Julia

Ниже представлена реализация метода прогонки в Julia:

```julia
function thomas_algorithm(a::AbstractVector, b::AbstractVector, c::AbstractVector, d::AbstractVector)
    n = length(d)
    
    # Проверки размерностей
    if length(a) != n || length(b) != n || length(c) != n
        error("Все входные векторы должны иметь одинаковую длину")
    end
    
    # Создаем копии для вычислений
    c_prime = zeros(n)
    d_prime = zeros(n)
    x = zeros(n)
    
    # Проверка устойчивости метода
    for i = 1:n
        if i > 1 && abs(b[i]) < abs(a[i]) + abs(c[i])
            @warn "Система не является диагонально доминирующей, метод может быть неустойчивым"
            break
        end
    end
    
    # Прямой ход прогонки
    c_prime[1] = c[1] / b[1]
    d_prime[1] = d[1] / b[1]
    
    for i = 2:n
        denominator = b[i] - a[i] * c_prime[i-1]
        if abs(denominator) < eps()
            error("Деление на ноль в строке $i при прямом ходе")
        end
        
        c_prime[i] = i < n ? c[i] / denominator : 0
        d_prime[i] = (d[i] - a[i] * d_prime[i-1]) / denominator
    end
    
    # Обратный ход прогонки
    x[n] = d_prime[n]
    
    for i = n-1:-1:1
        x[i] = d_prime[i] - c_prime[i] * x[i+1]
    end
    
    return x
end

# Версия, принимающая матрицу A и вектор b
function thomas_algorithm(A::AbstractMatrix, b::AbstractVector)
    n = length(b)
    
    # Проверяем, что матрица квадратная
    if size(A, 1) != n || size(A, 2) != n
        error("Матрица должна быть квадратной размера n×n")
    end
    
    # Извлекаем диагонали
    a = zeros(n)  # поддиагональ
    b_diag = zeros(n)  # главная диагональ
    c = zeros(n)  # наддиагональ
    
    # Заполняем вектор главной диагонали
    for i = 1:n
        b_diag[i] = A[i, i]
    end
    
    # Заполняем вектор поддиагонали
    for i = 2:n
        a[i] = A[i, i-1]
    end
    
    # Заполняем вектор наддиагонали
    for i = 1:n-1
        c[i] = A[i, i+1]
    end
    
    # Проверяем, что матрица действительно трехдиагональная
    for i = 1:n
        for j = 1:n
            if abs(A[i, j]) > eps() && abs(i - j) > 1
                error("Матрица не является трехдиагональной")
            end
        end
    end
    
    # Вызываем основную функцию метода прогонки
    return thomas_algorithm(a, b_diag, c, b)
end
```

## Приложения метода прогонки

Метод прогонки часто используется в следующих областях:

### 1. Численное решение дифференциальных уравнений

При дискретизации краевых задач для обыкновенных дифференциальных уравнений второго порядка часто возникают трехдиагональные системы. Например, для уравнения:

```
-u''(x) + p(x)u'(x) + q(x)u(x) = f(x), x∈[a,b]
u(a) = α, u(b) = β
```

Используя разностную схему, получаем трехдиагональную систему.

### 2. Кубические сплайны

При построении интерполяционных кубических сплайнов также возникают трехдиагональные системы для определения коэффициентов сплайнов.

### 3. Решение уравнения теплопроводности

При использовании неявных разностных схем для уравнения теплопроводности на каждом временном шаге необходимо решать трехдиагональную систему.

## Примеры

### Пример 1: Простая трехдиагональная система

Рассмотрим систему:
```
2x₁ - x₂ = 1
-x₁ + 2x₂ - x₃ = 0
-x₂ + 2x₃ = 1
```

В форме для метода прогонки:
- a = [0, 1, 1]
- b = [2, 2, 2]
- c = [1, 1, 0]
- d = [1, 0, 1]

Решение:

```julia
a = [0.0, 1.0, 1.0]  # a[1] не используется
b = [2.0, 2.0, 2.0]
c = [1.0, 1.0, 0.0]  # c[3] не используется
d = [1.0, 0.0, 1.0]

x = thomas_algorithm(a, b, c, d)
println("Решение: ", x)

# Проверка
A = [2.0 -1.0 0.0; -1.0 2.0 -1.0; 0.0 -1.0 2.0]
println("Невязка: ||Ax - d|| = ", norm(A * x - d))
```

### Пример 2: Численное решение ОДУ методом конечных разностей

Рассмотрим краевую задачу:
```
-u''(x) = sin(πx), x∈[0,1]
u(0) = u(1) = 0
```

Дискретизируя уравнение с шагом h = 1/(n+1), получаем систему:
```
-u[i-1] + 2u[i] - u[i+1] = h²sin(πx_i), i = 1, 2, ..., n
```

где x_i = i·h.

Решение:

```julia
# Параметры задачи
n = 10  # количество внутренних точек
h = 1.0 / (n + 1)  # шаг сетки

# Создаем трехдиагональную матрицу для дискретизации
A = zeros(n, n)
for i = 1:n
    A[i, i] = 2.0
    if i > 1
        A[i, i-1] = -1.0
    end
    if i < n
        A[i, i+1] = -1.0
    end
end

# Создаем правую часть
b = zeros(n)
for i = 1:n
    x_i = i * h
    b[i] = h^2 * sin(π * x_i)
end

# Решаем систему методом прогонки
u = thomas_algorithm(A, b)

# Вычисляем точное решение для сравнения
u_exact = zeros(n)
for i = 1:n
    x_i = i * h
    u_exact[i] = sin(π * x_i) / (π^2)
end

# Выводим результаты
println("Численное решение:")
println(u)
println()

println("Точное решение:")
println(u_exact)
println()

println("Погрешность (максимальная):")
println(maximum(abs.(u - u_exact)))
```

## Модификации и обобщения метода прогонки

### 1. Циклические трехдиагональные системы

Для систем с дополнительными ненулевыми элементами в позициях (1,n) и (n,1) (т.н. циклические или периодические трехдиагональные системы) требуются специальные модификации метода прогонки.

### 2. Блочно-трехдиагональные системы

Для систем, где элементы матрицы являются не скалярами, а матрицами (блоками), используется обобщение метода прогонки - блочный метод прогонки.

### 3. Параллельные версии метода прогонки

Для повышения эффективности на параллельных архитектурах разработаны различные параллельные версии метода прогонки, например, метод циклической редукции.

## Практические рекомендации

1. **Проверяйте диагональное преобладание** перед использованием метода прогонки для обеспечения устойчивости.
2. **Используйте повышенную точность** при расчетах, если возникают проблемы с точностью из-за накопления ошибок округления.
3. **Рассмотрите альтернативные методы** для плохо обусловленных трехдиагональных систем, например, метод Гаусса с выбором главного элемента.
4. **Для больших систем** эффективно используйте память, храня только ненулевые элементы матрицы (три диагонали).

## Задания для самостоятельной работы

1. Реализуйте метод прогонки для циклических трехдиагональных систем.
2. Исследуйте устойчивость метода прогонки для различных трехдиагональных систем с разной степенью диагонального преобладания.
3. Сравните эффективность метода прогонки с общим методом Гаусса для трехдиагональных систем разного размера.
4. Примените метод прогонки для решения краевой задачи с нелинейным дифференциальным уравнением, используя итерационный процесс линеаризации.
5. Реализуйте блочный метод прогонки для решения систем дифференциальных уравнений.
6. Разработайте параллельную версию метода прогонки для многоядерных архитектур. 